import pandas as pd
import argparse
from scipy.spatial import distance

TargetSet = {}
t = float('inf')
k = 0
query_latitude = 0
query_longitude = 0

def compute_cell(abscissa, ordinate, dataframe):
	# q might not be in the grid
	bool prune_layer = true
	for index, row in dataframe.loc[(dataframe['ordinate'] == ordinate) & (dataframe['abscissa'] == abscissa)].iterrows():
		distance = ((row['latitude'] - query_latitude)**2 + (row['longitude'] - query_longitude)**2)**0.5
		if len(TargetSet) < k:
			TargetSet[index] = distance
			t = max(TargetSet, key=TargetSet.get)
		else:		
			if distance < t:
				del_key = TargetSet.keys()[TargetSet.values().index(t)] # only one
				TargetSet.pop(del_key, None)
				TargetSet[index] = distance
				t = max(TargetSet, key=TargetSet.get)
				prune_layer = false

	return prune_layer

def pointe_to_cell(abscissa, ordinate):
	# find the cell
	xlow = min_latitude + abs(abscissa) * latitude_interval
	xhigh = min_latitude + (abs(abscissa) + 1) * latitude_interval
	ylow = min_longitude + abs(ordinate) * longitude_interval
	yhigh = min_longitude + (abs(ordinate) + 1) * longitude_interval

	return min(distance.euclidean((query_latitude, query_longitude), (xlow, ylow)), distance.euclidean((query_latitude, query_longitude), (xlow, yhigh)), distance.euclidean((query_latitude, query_longitude), (xhigh, ylow)), distance.euclidean((query_latitude, query_longitude), (xhigh, yhigh)))


if __name__ == "__main__":

	parser = argparse.ArgumentParser(description = "Nearest neighbor search technique on grid-indexed data")

	parser.add_argument('-x', type=float, help = "latitude of query location q", required=True)
	parser.add_argument('-y', type=float, help = "longitude of query location q", required=True)
	parser.add_argument('-k', type=int, help = "integer k", required=True)

	args = parser.parse_args()
	k = args.k
	query_latitude = args.x
	query_longitude = args.y

	df = pd.read_csv('Gowalla_totalCheckins.txt', sep="\t", header=None)

	df.columns = ["user", "check-in time", "latitude", "longitude", "location id"]

	max_latitude =  df['latitude'].max()
	max_longitude = df['longitude'].max()
	min_latitude =  df['latitude'].min()
	min_longitude = df['longitude'].min()

	latitude_interval = (max_latitude - min_latitude) / 100.0
	longitude_interval = (max_longitude - min_longitude) / 100.0

	df["abscissa"] = (df['latitude'] - min_latitude) // latitude_interval
	df["ordinate"] = (df['longitude'] - min_longitude) // longitude_interval

	#df.to_csv('Gowalla_totalCheckins_modified.txt', sep='\t')
	
	query_abscissa = (args.x - min_latitude) // latitude_interval
	query_ordinate = (args.y - min_longitude) // longitude_interval

	compute_cell(query_abscissa, query_ordinate, df)

	bool prune_layer = true

	i = 1

	while true:
		# layer
		for x in xrange(query_ordinate - i, query_ordinate + i):
			if pointe_to_cell(query_abscissa - i, x) <= t:
				prune_layer = compute_cell(query_abscissa - i, x, df)

		for x in xrange(query_ordinate - i, query_ordinate + i):
			if pointe_to_cell(query_abscissa + i, x) <= t:
				prune_layer = compute_cell(query_abscissa + i, x, df)

		for x in xrange(query_abscissa - i, query_abscissa + i):
			if pointe_to_cell(x, query_ordinate + i) <= t:
				prune_layer = compute_cell(x, query_ordinate + i, df)

		for x in xrange(query_abscissa - i, query_abscissa + i):
			if pointe_to_cell(x, query_ordinate - i) <= t:
				prune_layer = compute_cell(x, query_ordinate - i, df)

		if prune_layer == true:
			break

		i++
