#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <netdb.h>
#include <sys/types.h> 
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define BUFSIZE 1024
#define NUM_THREAD 4
#define true 1
#define false 0
#define CALCULATE_TIME

const int page_size = 4096;
int64_t nr_block = 4096 * 10000;
int64_t nr_total_pages = 4096 * 10000 * 8;

static pthread_mutex_t *comp_done_lock;
static pthread_cond_t *comp_done_cond;

struct CompressParam {
    int start;
    int done;
    pthread_mutex_t mutex;
    pthread_cond_t cond;
};
typedef struct CompressParam CompressParam;

static CompressParam *comp_param;

void error(char *msg) {
  perror(msg);
  exit(1);
}

struct thread_info {
  pthread_t thread_id;
  int       thread_num;
};

#define MULTIPLE_BIT 1024
#define MULTIPLE_TIME 1

static void dirty_pages(void *mem_head)
{
    char* var, *multiple_var;
    int64_t i, j;
    for (i = 0; i < (nr_block / page_size); ++i)
    {
      var = mem_head;
      var += i * page_size;
      *var = 'a';
      // for (j = 0; j < MULTIPLE_TIME; ++j)
      // {
      //   multiple_var = var + j*MULTIPLE_BIT;
      //   *multiple_var = 'a' + j;
      // }
    }
}
//__thread void *mem_head = NULL;
static void *thread_start(void *opaque)
{
  CompressParam *param = opaque;
  int64_t mem_size = nr_total_pages;
  void *mem_head = malloc(mem_size);
  if (mem_head == NULL)
  {
    fprintf(stderr, "mem NULL\n");
  }

  int block_index = 0;

  while (1) {
        pthread_mutex_lock(&param->mutex);

        while (!param->start) {
            pthread_cond_wait(&param->cond, &param->mutex);
        }
        // if (mem_head != NULL)
        // {
        //   free(mem_head);
        //   mem_head = NULL;
        // }
        char *block = (char*)mem_head + block_index * nr_block;
        fprintf(stderr, "mem NULL 1\n");
        dirty_pages(block);
        fprintf(stderr, "mem NULL 2\n");
        param->start = false;
        pthread_mutex_unlock(&param->mutex);
        pthread_mutex_lock(comp_done_lock);
        param->done = true;
        pthread_cond_signal(comp_done_cond);
        pthread_mutex_unlock(comp_done_lock);
        block_index++;
        if (block_index == (nr_total_pages / nr_block))
        {
          block_index = 0;
        }

  }
}

static inline void start_dirty_pages(CompressParam *param)
{
    param->done = false;
    pthread_mutex_lock(&param->mutex);
    param->start = true;
    pthread_cond_signal(&param->cond);
    pthread_mutex_unlock(&param->mutex);
}

static void wait_dirty_pages_done()
{
    int idx, thread_count;
    thread_count = NUM_THREAD;

    for (idx = 0; idx < thread_count; idx++) {
        if (!comp_param[idx].done) {
            pthread_mutex_lock(comp_done_lock);
            while (!comp_param[idx].done) {
                pthread_cond_wait(comp_done_cond, comp_done_lock);
            }
            pthread_mutex_unlock(comp_done_lock);
        }
    }
}

int main(int argc, char **argv) {
  int sockfd;
  int portno;
  int clientlen;
  struct sockaddr_in serveraddr;
  struct sockaddr_in clientaddr;
  struct hostent *hostp;
  char buf[BUFSIZE];
  char *hostaddrp;
  int optval;
  int n;

  if (argc != 2) {
    fprintf(stderr, "usage: %s <port>\n", argv[0]);
    exit(1);
  }
  portno = atoi(argv[1]);

  sockfd = socket(AF_INET, SOCK_DGRAM, 0);
  if (sockfd < 0) 
    error("ERROR opening socket");

  optval = 1;
  setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, 
	     (const void *)&optval , sizeof(int));

  bzero((char *) &serveraddr, sizeof(serveraddr));
  serveraddr.sin_family = AF_INET;
  serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
  serveraddr.sin_port = htons((unsigned short)portno);

  if (bind(sockfd, (struct sockaddr *) &serveraddr, 
	   sizeof(serveraddr)) < 0) 
    error("ERROR on binding");

  int tnum, s;
  void *res;
  struct thread_info *tinfo;

  tinfo = calloc(NUM_THREAD, sizeof(struct thread_info));
  if (tinfo == NULL)
    fprintf(stderr, "calloc");

  comp_param = malloc(sizeof(struct CompressParam) * NUM_THREAD);
  memset(comp_param, 0, sizeof(struct CompressParam) * NUM_THREAD);
  comp_done_cond = malloc(sizeof(pthread_cond_t));
  memset(comp_done_cond, 0, sizeof(pthread_cond_t));
  comp_done_lock = malloc(sizeof(pthread_mutex_t));
  memset(comp_done_lock, 0, sizeof(pthread_mutex_t));
  
  pthread_cond_init(comp_done_cond);
  pthread_mutex_init(comp_done_lock);

  for (tnum = 0; tnum < NUM_THREAD; tnum++) {
    tinfo[tnum].thread_num = tnum + 1;

    comp_param[tnum].done = true;
    pthread_mutex_init(&comp_param[tnum].mutex);
    pthread_cond_init(&comp_param[tnum].cond);

    s = pthread_create(&tinfo[tnum].thread_id, NULL, &thread_start, comp_param + tnum);
    if (s != 0)
      fprintf(stderr, "pthread_create");
  } 

  clientlen = sizeof(clientaddr);
  int i, val = 0;
  struct timeval t1, t2;
  long elapsed_time;

  while (1) {
    val++;
    n = recvfrom(sockfd, buf, BUFSIZE, 0, (struct sockaddr *) &clientaddr, &clientlen);
    if (n < 0)
      error("ERROR in recvfrom");

#ifdef CALCULATE_TIME
    gettimeofday(&t1, 0);
#endif

    for (i = 0; i < NUM_THREAD; ++i) {
      start_dirty_pages(&comp_param[i]);
    }

    wait_dirty_pages_done();
#ifdef CALCULATE_TIME
    gettimeofday(&t2, 0);
    elapsed_time= (((t2.tv_sec - t1.tv_sec)*1000000) + t2.tv_usec) - (t1.tv_usec);
    printf("%ld microseconds (us)\n", elapsed_time);
#endif    
    n = sendto(sockfd, &val, sizeof(val), 0, (struct sockaddr *) &clientaddr, clientlen);
  }

  for (tnum = 0; tnum < NUM_THREAD; tnum++) {
    s = pthread_join(tinfo[tnum].thread_id, &res);
    if (s != 0)
      fprintf(stderr, "pthread_join");
  }

}
