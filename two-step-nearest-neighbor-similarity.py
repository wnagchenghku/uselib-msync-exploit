import numpy as np
import argparse
from rtree import index
from scipy.spatial import distance
import time

if __name__ == "__main__":

	parser = argparse.ArgumentParser(description = "Nearest Neighbor Similarity Queries")

	parser.add_argument('-q', nargs = 32, type = float, help = "query vector q", required = True)
	parser.add_argument('-k', type = int, help = "dimension k", required = True)

	args = parser.parse_args()
	
	start = time.time()
	
	# Each set of features is stored in a separate file.
	# For each file, a line corresponds to a single image.
	# The first value in a line is is the image ID and
	# the subsequent values are the feature vector (e.g. color histogram, etc.) of the image.
	data = np.loadtxt('ColorHistogram-test.asc', dtype = float, usecols = range(1, 33))

	# Let us assume that it is centered, i.e. column means have been subtracted and are now equal to zero.
	mean_value = np.mean(data, axis = 0)
	data_centralized = data - mean_value

	U, s, V = np.linalg.svd(data_centralized, full_matrices = False)

	S = np.diag(s)

	assert np.allclose(data_centralized, np.dot(U, np.dot(S, V)))

	B = np.dot(U[:, :args.k], S[:args.k, :args.k])

	p = index.Property()

	p.dimension = args.k

	# delete cached file
	idxkd = index.Index('kd_index', properties = p)

	for index, x in enumerate(B):
		idxkd.insert(index, tuple(np.concatenate(([x, x])).tolist()))

	low_dim_q = np.dot(np.matrix(args.q) - mean_value, np.transpose(V))[:,:args.k]

	low_dim_p_index = list(idxkd.nearest(tuple(np.concatenate((low_dim_q, low_dim_q), axis = 1).tolist()[0]), 1))[0]

	d = distance.euclidean(data[low_dim_p_index], args.q)

	min = float('inf')

	for idx in list(idxkd.intersection(tuple(np.concatenate((low_dim_q - d, low_dim_q + d), axis = 1).tolist()[0]))):
		D = distance.euclidean(data[idx], args.q)
		if min > D:
			min = D
			p_index = idx

	end = time.time()
	elapsedTime = end - start

	print 'Nearest neighbor image ID', p_index

	print 'Running time in seconds', elapsedTime
